### REST APIについて自分の言葉でまとめてください
- Web
    - HTTPなどのインターネット関連技術を利用してメッセージの送受信を行う技術、またはそれらの技術を利用して展開されたサービス
- API(application programming interface)
    - 機能やデータを外部から呼び出して利用できるよう定めた規約
- WebAPI
    - Webサービスで提供している 機能やデータを外からプログラムが読み取りやすい形で利用できるよう定めた規約規約またはその実装（第三者が情報を利用して新たな機能を開発すること）
    - そのAPI独自の機能を公開する。一般的などこでもできる機能は公開しても価値がないので後悔しない
- RESTとは、Web上のリソースを、HTTPメソッドを使ってシンプルに操作する設計ルールです。
「representational state transfer」の略。2000年にRoy Foieldingというアメリカの学者が発表したRESTに関する論文が元である。
REST APIの設計原則として以下のようなものがある

- クライアント-サーバー構造：クライアントとサーバーで関心事を分離している。
- リソース指向：全情報をリソースとして扱い、一意のURIでそれぞERのリソースを識別する。
- ステートレス：各リクエストは、以前のリクエストとは独立している（依存していない）。
- 統一インターフェース：HTTPメソッド（GET, POST, PUT, DELETE等）を使用して、リソースに対する操作を定義する。
- キャッシュ可能：レスポンスにキャッシュ情報を含めることで、クライアント側でのキャッシュが可能。
- 階層化システム：システムを階層構造（3層アーキテクチャ）にする。ここの層は独立して設計される。

| URI          | HTTP method |
|--------------|-------------|
| /movies      | GET         |
| /movies      | POST        |
| /movies/{id} | GET         |
| /movies/{id} | PUT         |
| /movies/{id} | DELETE      |
### movieをリソースとして CRUD操作のURI、HTTPメソッドを定義してください
定義には下記のmarkdownテーブルのフォーマットを使用してください。
URI	HTTP method
WIP	WIP
WIP	WIP



### メモ

| CRUD | 操作  | HTTPメソッド |
| ---- | ----- |-----|
| CREATE | 作成|POST|
| CREATE | 作成|PUT|
| READ | 読み取り |GET|
| UPDATE | 更新|PUT|
|DELETE|削除|DELETE|
- CREATEのPOSTとPUTはリソース名が未定ならばPOST、リソース名が決まっていればPUTをする

- WEB API公開によるリスクと対策

    | リスク | 原因  | 対策 |
    | ---- | ----- |-----|
    | ユーザが減る | 他サービスが優れている、作り込む機能を優先順を間違えている |ユーザ獲得している他さーびすの機能を取り込む|
    | ユーザが減る | 他サービスが劣っている、自サービスが落とされている |該当サービスに対してWEBAPIキーの提供を停止|
    | リソースが圧迫される | API化することで機械的にデータが取りやすくなっている |該当サービスに対してWEBAPIの利用制限をかける|

- 副作用
    - リソース（データ）が改変されること
    - 副作用があるのはDBテーブルの店舗名を書き換える更新処理はデータが書き換わっていルもの
    - 反対に副作用のない操作はGETのようなデータ自体は改変されないもの
- 安全
    - 副作用がないこと。
    - ＝リソースの状態を変化させない読み取り専用の操作(GET,HEADなど)
- 冪等
    - 何度実行しても同じ結果が得られる。副作用の有無は問わない
    - 副作用の有無は問わない
    - 副作用のある操作で冪等な操作は更新処理で、毎回No1の店舗を指定して更新をかけるというやり方だと冪等。（PUTやDELETE）
    - 副作用のない冪等はデータの取得（GET、HEAD）
- 安全でも冪等でもない操作は、「データ登録」（POST）


- section3
    - RESTFUL（representational state transfer）(分散型システムにおける設計原則群、つまり設計ルールのこと)
        - RESTで求められる原則に従っている
        - representational state transfer(分散型システムにおける設計原則群、つまり設計ルールのこと)
        - Roy fieldingというアメリカの学者がRESTNo設計ルールを考えた。
    - REST原則６種類
        - クライアントサーバ
            - クライアントとサーバ側で関心ごとを分離する
            - クライアント側がトリガー、サーバ側が受け身
        - 階層化システム
            - 多層アーキテクチャシステム
            - WEB,AP,DB（これらが蜘蛛の巣状にネットわーっ具を作ってる）
            - 階層化システムのメリット
                - 各システム（コンポーネント）に役割を決めて独立させることで進化と再利用ができる
                - マイクロサーボスのような概念
            - デメリット
                - データ処理にオーバーヘッドが増加
                - ユーザから見ると応答が悪くなる
        - コードオンデマンド
            - クライアントコードをダウンロードして実行できる
            - リリース後もサーバ側の処理を修正してクライアントに反映できる
            - 「on demand」の意味・翻訳・日本語 - 要求に応じて、要求があり次第
            - メリット
                - リリース後リリース後のくらいあんとに対して機能追加ができる
                - サーバの負荷が下がる（クライアントに処理を委譲できる）
                - 評価が複雑になる（多数のブラウザとか）

        - ステートレス
            - ステートフルは以前の状態を覚えてくれている（前の会話を前の会話の状態を記憶して次の会話をする）
            - ステートレス（前の状態を保存しない。それぞれの会話が独立している、単独で成り立つ）
            - このステートレスを制約としていうと、「サーバはリクエストだけでコンテキストを理解できる」
            - つまりサーバの保存されたコンテキスト情報（サー婆セッション）は使わずに、状態はクライアント上に保存され、各単独のリクエストで情報が成り立っているというのが制約
            - メリット
                - 単一のリクエスト以外見る必要がないので監視が容易
                - 障害の発生したリクエストだけ回復すればいいので復旧が容易
                - リクエスト全体でサーバリースを共有する必要がないのでスケールが容易
            - デメリット
                - 単一のリクエストで完結させるため、リクエストデータに重複がある
        - キャッシュ制御
            - クライアント側でレスポンスがキャッシュできるようにしてくれよなってこと
            - レスポンスは明示的、暗黙的に キャッシュ可能
            - 適切にキャッシュすることでクライアント・サーバ間の通信が排除されユーザ体験の向上、リソーすの向上、拡張性の向上が見込まれる
            - 適切にキャッシュすれば必要が情報だけリクエストすれば良くなる→効率上がる
            - メリット上記。
            - 古いデータを戻してしまうとデータの不整合が起こり、画面で正しくない情報が表示される。
        - 統一インタフェース
            - 中身は以下の4つの制約で成り立っている
            - リソースの識別
                - リソースとは名前がつけられるあらゆるもの。サーバ側に保持される全データ。（ドキュメント、人、物、画像、サービス、状態）
                - リソースの識別＝＝URIを用いてサーバに保存されたデータを識別するということ。普通のURLでサーバのデータを撮りに行くこと
                - Web上にあるあらゆるファイルを認識するための識別子の総称
                - URIはリソースを識別するもの。URIではリソースでパスを指定する
            - 表現を用いたリソース操作
                - 表現＝リソース（サーバに保持された）のある断面（クライアントクライアントへ返されるレスポンスやサーバへポストするデータのこと）←この断面のデーtを受け取ったり渡したりしている。断面情報を利用してサーバのデータを操作する
                - あるタイミングにおける断面を受け取ったり渡したりしているから、これを表現と言っている（断面情報を利用してサーバ上のデータを操作する）（Authorizationも送信する）
            - 自己記述メッセージ
                - 自己記述＝データ自身がデータの中身を説明している
                - メッセージ＝サーバへリクエストするデータ、クライアントへレスポンスするデータ
                - つまりメッセージ内容がなんであるかヘッダに書いてあればOKっていうこと
                - ContentTypeをヘッダーに記述している、これが自己記述メッセージ
            - アプリケーション状態エンジンとしてのハイパーメディア
                - HATEAOS(hypermedia  as the engine of application state)
                - つまりはレスポンスに現在の状態を踏まえて関連するハイパーメディアを含めてねってこと（検索結果ページにおける次ページのリンクとか）
            - メリット
                - システムアーキテクチャ全体が簡素化されわかりやすくなる
                - 提供するサービスに集中でき独自の進化ができる
                - 取り決めが決まっているので異なるブラウザでも同じ画面を表示できる
            - デメリット
                - 標準化によって効率性が犠牲になる
    - RESTAPI設計レベル（どれだけRESTに準拠しているか）
        - LEVEL0,HTTPを使っている
            - RESTAPIの基本レベル。RPC（remote pocedure call）スタイルのXML通信のようなものを定義している。RPC＝remote procedure call（ネットワーク越しに別コンピュータ上のプログラムを実行する仕組み）
        - LEVEL1　リソースの概念を導入
            - リソースごとにURLが分割されている
            - リソースに対して複数のURLが定義されている
        - LEVEL2　HTTPの動詞を導入
            - リソースに対してHTTPメソッドを使ったCRUD操作が行われている

        - LEVEL3　HATEOAS導入している
            - レスポンスにリソース間のつながりが含まれる（レスポンスに現在の状態に関連するハイパーリンクが含まれる）
    - URI設計（URIを設計すると、より良いAPIになるか）
        - 短く入力しやすい（冗長でない。意味が伝わることが重要）
            - シンプルで覚えやすいものにすることで入力ミスを防げる
            ✖︎ GET http://api.example.com/service/api/search
            ⚪︎ GET http://api.example.com/search
        - 人が呼んで理解できる（できる負だけ省略しない）
            - ✖︎ GET http://api.example.com/sv/u
            - ○ GET http://api.example.com/users
        - 大文字小文字語混在していない（全て小文字）
            - 一般的に”間違いにくくする”には”統一する”ことが重要
            - なのでAPIでは小文字に統一
            - ✖︎ GET http://api.example.com/Users
            - ○ GET http://api.example.com/users
        - 単語はハイフンで繋げる
            - ✖︎ GET http://api.example.com/popular_users
            - ○ GET http://api.example.com/popular-users
            - しかし単語の連結をするくらいならURIを見直して方がいい
            - ○ GET http://api.example.com/users/popularなど
        - 単語は複数形を利用する
            - URIで表現しているのはリソースの集合(usersという集合の中に存在するuserIDが0005なので。)
            - ✖︎ GET http://api.example.com/user/0005
            - ○ GET http://api.example.com/users/0005
        - エンコードを必要とする文字を使わない
            - URIから意味が理解できない
            - ✖︎ GET http://api.example.com/user/ユーザ名
            ↓
            - ✖︎ GET http://api.example.com/user/%E3%83%A6%E3%83%BC%E3%B6%E3%83%BC%
            -URIから意味が理解できない（実際は動作するが。）
        - サーバ側のアーキテクチャを反映しない
            - 悪意のあるユーザに脆弱性をつかれる
            - ✖︎ GET http://api.example.com/cgi-bin/get_user.php?id=12345
            - phpでサーバサイド動いてるな〜とかわかってしまう
        - 改造しやすい（Hackable）
            - システム依存の設計は意味が理解できない
            - ✖︎ GET http://api.example.com/user/alpha/23456
            - ✖︎ GET http://api.example.com/user/beta/234556
            - 意味のわからない単語は含めない。サーバがalphaとbetaに分かれているとしても。
        - ルールが統一されている
            - 一定のルールに従い設計することで間違いを防ぐ
            - ✖︎ GET http://api.example.com/user/id=0005
            - ✖︎ GET http://api.example.com/user/0005/messages
            -↑行はパラメータの渡し方が統一されてない（上がクエリパラメータ。下がパスパラメータ）なので以下のようにパスパラメー＾たにしてあげる

            - ✖︎ GET http://api.example.com/friends/12345
            - ✖︎ GET http://api.example.com/friends/12345/messages
    - HTTPメソッドの適用(HTTPメソッドとURLをどう組み合わせて使うか)
        - GET /v1/users/123 HTTP/1.1
            Host:   api.example.com
        - リソースが「/v1/users/123」,HTTPメソッドはリソースに対する操作（上で言うとGET）
        
        | メソッド名 | 説明  |
        | -------- | --------- |
        | GET | リソースの取得 |
        | POST | リソースの新規登録(データ作成時にリソース名が決まっていない)|
        | PUT | 既存リソースの更新、 リソースの新規登録（データ作成時にリソース名が決まっている）|
        | DELETE |リソースの削除|


        | 操作 | API実装例  |補足|
        | -------- | --------- |-----|
        | ユーザ情報の一覧取得 | GET http://api.example.com/users |ユーザ情報の一覧を取得するというAPIであればGETで一覧を取得できる(usersと複数形なので一覧nの取得になる)|
        | ユーザの新規登録 | POST http://api.example.com/users |↑と同じURIに対してPOSTを指定するとユーザの新規登録という意味になる|
        | 特定ユーザの取得 | GET http://api.example.com/users/12345 |(12345とある通りユーザを特定している場合)GETをつければ特定してユーザの情報を取得|
        | ユーザの更新 | UPDATE http://api.example.com/users/12345 |(12345とある通りユーザを特定している場合)PUTを指定するとそのユーザの更新|
        | ユーザの削除 | DELETE http://api.example.com/users/12345 |(12345とある通りユーザを特定している場合)そのユーザの削除|
        - URIは同じでも、HTTPメソッドによって意味合い、リソースへの操作を切り替えられる。
    - クエリとパスの使い分け
        
        | 種類 | 概要  |
        | -------- | --------- |
        | クエリパラメータ  | URLの末尾の？に続くキーバリューのこと GET http://api.example.com/users?page=3 |
        | パスパラメータ | URlの中に埋め込みをするパラメータ GET http://api.example.com/users/123 |
        - どう使い分けるかの基準2つ
            - 一意のリソースを表すのに必要かどうか
                - この必要がある場合はおあすパラメータを使う
            - 省略可能かどうか
                - 可能な場合、クエリパラメータを使う
            - パスは対象のリソースまでの道のり、クエリは検索の際の条件って意味合いがある

            - 一意のリソースがパスパラメータになる理由は、パスがリソースそのものを示す「場所」だからです。

                - リソースの場所を明確に示す: パスはリソースの位置を指し示すため、一意のリソースを特定する際にそのリソースの場所（IDなど）をURLの一部として表現します。例えば、/users/123は「ユーザーID 123というリソースがここにある」と示します。

                - 意味的に正確: クエリパラメータは条件やフィルタリングのために使うべきで、リソースそのものを表すパスパラメータとは役割が異なります。/users/123が特定のユーザーを指すのに対し、/users?id=123は条件に近い使い方になります。

            このように、一意のリソースを指す時はそのリソースの「場所」を表すためにパスパラメータを使います。
    - ステータスコード
        - 1✖︎✖︎
            - 情報
            - 100 continue サーバがリクエストの最初の部分を受け取り、まだサーバから拒否されていないこと
            - 101 プロトコルの
        - 2✖︎✖︎
            - 成功
        - 3✖︎✖︎
            - リダイレクト
        - 4✖︎✖︎
            - クライアントサイドに起因するエラー
        - 5✖︎✖︎
            - サーバーサイドに起因するエラー
        - 1✖︎✖︎
    - HTTPメソッドとステータスコード
        - GET
            - データ取得

            | 成功 | 失敗 |
            | -------- | --------- |
            | 200ok 正常|　404 bad request クライアント側のリクエストg間違っている|
            | 304 not modified|401 unauthorized リクエストしてきた人が誰かわからない |
            ||　403 forbidden 誰だかわかったが、    リクセスとしてきたリソースにアクセス権がない|
            ||　404 純粋にリクエストしてきたリソースがない場合|
            || 429 too many request レートリミット制限を超えた|
            ||　500 internal server error サーバ側の障害あり|
            ||　　503 service unavailable サーバ側が高負荷状態　|
            - キャッシュ利用をして返却する場合は３０４
        - POST

            | 成功 | 失敗  |
            | -------- | --------- |
            |200OK POSTでデータ登録ができ、データ登録した結果のデータをレスポンスに含む||
            |201 ||
            |||
            |||
            |||
            |||
            |||
            |||
        - 
        - 
        - 
    - データフォーマット
        - XML
            - タグで記述
            - タグには属性つけられる
            -

        - JSON
            - 波括弧で囲う
            - XMKに比べてデータ量が減らせる
            - jsを元にしたフォーマット
        - JSONP
            - javascriptコード
            - json with padding
            - クロスドメインでデータを受けわたあしできる
        - 
        - 
    - データの内部構造
        - エンベロープ→レスポンスボディ内のメタ情報。（レスポンスのヘッダーとかぶっている）
        - オブジェクトはできるだけフラットにする。（JSON内部のネストを減らすようにする）
        - ページネーションをサポートする情報を返す
        - プロパティの命名規則はAPI全体で統一する
        - 
    - APIバージョンの表現
        - APIにバージョンを含めると特定バージョン指定でアクセスできるので、クライアント側で突然エラーにならない
        - 複数バージョンを並列稼働させるので、ソースやDBの管理が複雑になる
        - APIのURLにバージョンを含めるかどうかは、世間一般に公  　開するサービスかどうかになる。
        - 
        - バージョンはパス、クエリ、ヘッダーに入れる３パターンある。
        - パスに入れるのが一番多いパターん
        - バージョンは１、２、３の３パターン
        - 「メジャー: 後方互換しない修正を行った時にバージョンが上がる」「マイナー: 後方互換する機能追加した時にバージョン上がる」「パッチ:単純なバグ修正した時に上がる 」
        - 
    - OAuthとOpenID Connect
        - 認証は本人特定すること。
        - 認可はアクセス制御すること
        - 最初にユーザがサーバへアクセスしてきた時に、誰であるかの本人特定が認証。（ログインすると言うこと）
        - そしてログイン後にリソースに対してアクセスして良いかどうかを判断制御するのが認可
        - OAuthとOpenID Connectの違い
            - どちらも認可の仕組み（認可なのでアクセス制御の仕組み）
            - OpenID ConnectはOAuth(認可)＋本人情報取得を加えた仕組み
        - OAuth
            - Authorization code フロー
                - サードパーティーのアプリに対して連携せっっていに依頼する(facebook,line,yahoo!連携的な)
                - 画面がリダイレクトされfacebookならfacebooknおログイン画面が表示される
                - ユーザはログインし、サードパーティに対する処理の許可を与える
                - 許可を与えるとサービス側からサードパーティアプリに対して、「認可コード」が転送される
                - に受け取った認可コードを使ってサードパーティは再度サービス（facebook等）にアクセスする
                - サービス側からアクセストークンのキー情報が返却される
                - このトークンはユーザを特定しかつサービスに対する認可を持たせたキー情報になります。
                - このアクセストークンを用いると、あるユーザがあるサードパーティにアクセスした時、そのユーザのアクセスと＾くんを使ってサービスにたいしてAPIwo利用することができる
        - OpenID connect
    - JSON WEB TOKEN(JWT) ジョットと呼ぶ。
        - 主に3つの特徴が亜ある
            - 署名による改ざんチェック
            - URL-safeなデータ
            - データの中身はJSON形式
        - 主な用途
            - 認証結果をサーバサイドで保存せずクライアントサイドで保持する
        - 基本構造
            - 中身はピリオド2つで括られた３要素
            - ヘッダー、ペイロード、署名
        - ヘッダー（署名で使うアルゴリズムなどを定義する）
            - typ項目→JWTで固定
            - alg項目→署名に使うアルゴリズム（HS256,ES256などなど）
        - 
        ```json
        {
            "type":"JWT",
            "alg":"ES256"
        }
        ```

        - ペイロード（保存するデータをなんでも入れちゃおうってとこ）

