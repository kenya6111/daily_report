## 取り組んだ課題一覧

## わかったこと
- 1~6章
    - シングルクオーテーションで括らずに記述したリテラルは数値として扱われる
    - シングルクオーテーションで括ったリテラルは文字情報として扱われる
    - シングルクオーテーションで括られ、かつ'2024-08-31'のような一定の形式のリテラルは日付情報として扱われる
    - CHARは固定長。あらかじめCHAR(10)なら１０バイト分領域が確保される。なので三文字だけ入れてても残り七文字は空白として埋められル。

    - VARCHARは可変長。入力文字の長さに合わせて領域の確保が行われる。
    - 以上よりCHARは固定長なので格納数rデータの長さが一定の場合に使うと良い（郵便番号、社員番号）
    　　　　　VARCHARは氏名や本の名前など、格納データの長さが決まっていないものに対して使うと良い
    - 社員番号のように社員テーブルの情報を設計する上で自然と出てくる主キーは自然キーという
    - 逆に購入履歴テーブルのように、テーブルのカラムを設計していっても主キーのようなカラムが登場しない場合に作る主キーは人工キー、代替キーという。
    - IN句＝ANY
    - NOT IN ＝＝＜＞ANY
    - OFFSET 先頭から除外する行数 ROWS で先頭から除外する行数を指定
    - FETCH NEXT 取得行数 ROWS ONLY　で取得したい行数を指定

    - ANYとINの違い
    - 以下の二つは同じ結果。
        - select * from 家計簿 where 出金額 IN(select 出金額 from 家計簿 where 出金額 > 4000);
        - select * from 家計簿 where 出金額 = ANY(select 出金額 from 家計簿 where 出金額 > 4000);
    - 違いとしては、INは「＝」を内包しており、比較演算子は記述不要
    - ANYはその前に比較演算子の記載必要(「=」「<」「>」「>=」等々)
    - つまり「IN」は「=ANY」と同じである。
    - JOINとUNIONの違い
    - UNIONは、UNIONとUNION ALLの2つがある。
        - UNION は重複を削除して出力。重複チェックが入るのでUNION ALLよりは遅くなる(和集合)
        - UNION ALLは中副業をまとめずにそのまま全て出力
        - UNIONは結合するテーブルの列は同じ（列数が同じかつ各列のデータ型が同じであれば一応結合はできる。同じデータ型の全く違うカラムでも結合はできる。もしくはNULLを入れる）でなければいけない
        - ちなみにEXCEPTは差集合、INTERSECTは積集合
    - 右記のサイトがわかりやすい（https://it-kyujin.jp/article/detail/791/）
    - UNIONは2つのselectのの結果を縦にガッチャンコするイメージ。
    - JOINは2つのテーブルの共通のカラムを元に横に繋げるイメージ
    - https://gotto50105010.hatenablog.com/entry/2018/12/06/223615
    - case演算子について。主に２パターン書き方があるß
        - ```sql
        select 費目,出金額,
            case 費目 when '居住費用' then '固定費'
                    when '水道光熱費' then '固定費'
                    else '変動費'
            end as 出費の分類
        from 家計簿 where 出金額 > 0
        ```
        -```sql
        select 費目,入金額,
            case when 入金額 < 5000 then 'お小遣い'
                when 入金額 < 10000 then '一時収入'
                else '想定外の収入です'
            end as 収入の分類
        from 家計簿 where 入金額 > 0
        ```
    -　WHEREとHAVING
        - HAVINGはwhereと同じ条件で絞る機能だが、HAVINGは集計処理を行った後の結果に対して絞る機能
    - COALESCE関数
        - coalesce関数に渡された引数のうち、最初に登場するNULLでない値を返す
        ```sql
        selct COALESCE('A','B','C');  →A
        selct COALESCE(NULL,'B','C');  →B
        selct COALESCE(NULL,NULL,'C');  →C
        ```

        ある列にNULLの格納されている行がある場合、単にselectすると何も表示されないので
        そういった場合に、coalesce関数を使う
        ```sql
        select 日付,費用,
                coalesce(メモ,'nuLLだよ！') as メモ,
                入金額,
                出金額
        from 家計簿
        ```


    - TRUNC関数
        - 指定桁で切り捨てる
        ```sql
        select TRUNC(123456, -1);　→123450
        select TRUNC(123456, -2);　→123400
        select TRUNC(123456, -3);　→123000
        select TRUNC(123456, -4);　→120000
        select TRUNC(123456, -5);　→100000
        ```
    - ROUND関数
        - 指定桁で四捨五入する
        ```sql
        select ROUND(123456, -1); →123460
        select ROUND(123456, -2); →123500
        select ROUND(123456, -3); →123000
        ```
        // 第２引数（開始位置）にマイナス値を指定した場合は、文字の先頭が指定されたものとみなされます。
            第３引数（取得桁数）にマイナス値を指定した場合は、エラーになります。

        →は？なんでやねん！最後からインデックス数えさせろや！！！
        そこでそれ専用の関数があるらしい
        RIGHT関数を使って、文字列の最後から指定した数の文字を取得できる。
        ```sql
        SELECT RIGHT('abcdef', 2); → ef
        ```

        LENGTH関数などを使って、文字列の長さに基づいて開始位置を計算することもできます。
        ```sql
        SELECT SUBSTRING('abcdef', LENGTH('abcdef') - 2 + 1, 2);  -- 結果: 'ef'
    ```
-7章-----------------------
    - 副問い合わせには３種類ある
        - 単一の値による問い合わせ、列挙の値の問い合わせ、表形式の問い合わせ
        - 単一の値の服問い合わせ（１行１列＝１セル値を使う）
        ```sql
        select 家計簿集計
            set 平均 =(select AVG(出金額)
                        from 家計簿アーカイブ
                        where 出金額 > 0
                        and 費目='食費')
        where 費目='食費'
        ```
        - 列挙の値の問い合わせ（n行１列の結果を使う）
            ```sql
            select * from 家計簿
            where 費目 IN (select 費目 from 家計簿)
            ```
        - 表形式の問い合わせ(n行m列の結果を使う)
        ```sql
        select SUM(SUB.出金額)as 出金額合計
        from (select 日付,費目,出金額
                from 家計簿
                UNION
                select 日付,費目,出金額
                from 家計簿アーカイブ
                where 日付 >= '2024-01-01'
                and 日付 <= '2024-01-31') as SUB
        ```
-8章--------------------
- テーブルを複数に分ける理由、メリット
    - 値が変更になった場合、その修正の負荷が段違い(値を別テーブルに分け外部参照を使えば素音別テーブルを更新するだけで済むが、１テーブルに全て詰め込むと該当行全て更新する手間がかかる)
    - 1テーブルにさまざまな情報を詰め込むと管理が大変
    - ヒューマンエラーの巣窟となる（１行１行updateするのは無謀）
    - left join
        - 結合される側に合わせる結合の仕方。
            結合相手に該当行がない場合はnullで出力する
    - right join
        - 結合相手に合わせる結合の仕方
        - 結合される側の行がない場合はnullで出力する
    - inner join
        - 結合結合される側、結合する側、両方に存在する行だけ出力
- section9---------------

- ロック
    - 一連のSQL操作（口座のお金を１万マイナス→マイナス分引き出す）をする際に、他の一連のSQL操作が割り込まないようにすること
    - コミットorロールバックにてロックが解除される。そして他のトランザクションが実行される。
- トランザクション→一連のSQLを一塊として捉えたもの。原子性という。
    - 一部だけ実行されてはならず、全て実行されるか、全て実行されないかの0,100の考え方。コミットするか。ロールバックするか。
- トランザクションを使うことで以下のようなSQL実行時の不具合は避けられる
    - 友人にお金を振り込んだ際に、自身の銀行口座でUPDATEでお金を減らし,相手の口座にUPDATEでお金を増やすって時に1つ目の処理で処理が中断し、自身の口座からお金は減ったが相手の口座位には振り込まれていない。みたいな。
-   - 問題なく最後まで処理が進めば、変更内容を確定（コミット）し、途中で何かしら問題発生すれば無かったことにする（ロールバック）
- 以下のようにトランザクションの指示を書く
- ```SQL
BEGIN;  ←以降のSQLを1つのトランザクションとする指示
INSERT into 家計簿アーカイブ
select * from 家計簿 where 日付= <= '2024-01-31';
delete from 家計簿 where 日付 <= '2024-01-31';
COMMIT;　←ここまでの処理を1つのトランザクションとして確定する。
```
- ダーティーリード→まだコミットされていない変更をほかの人が読み取ってしまうこと
    - 例えば、口座から１万を引き出す（未コミット）。残高３万になる。（仮の残高）←次にガス代が引き落とされる。残高が２万になる。→最初の引き出し処理がキャンセルされてロールバック→そしてガス代の引き落としがコミットさレル→残高2万という恐ろしいことになる
- 反復不能読み取り
    - select文を２回時効する際に、間で他の人がテーブルの値をUPDATEしまい、前後の結果が変わってしまうこと
- ファントムリード
    - select文を２回時効する際に、間で他の人がテーブルにINSERTしてしまい、算出した行数の結果が変わってしまうこと
- デッドロック
    - 2つのトランザクションがロックしつつお互いを参照して、永遠に処理が終わらなくなってしまう
- 
- section10-----------------------
- 本の索引を使った方が検索が早いように、DBにおいてもindexを作成した方が検索スピードが速い
- ビュー→繰り返し同じSQLを書くのは面倒なので、よく使う結果を保存しておけること。
- DDL→（ create,alter,drop,truncate）
- DML→（select,insert,update,delete,）
- TCL→（commit,rollback,set transaction,savepoint）

- section11 (さまざまな支援機能)
- 検索をはやくするには
    - インデックスを作成する
    - どのようなSQLによってSQLのインデっクスによる高速化が見込まれるか
        - index列をwhere句に指定した場合
        - インデックス列をorder by に指定した場合
        - インデックス列をJOINの結合条件に指定した場合
- section12
    - DB構築のインプットとアウトプット
        - INPUT 要件、お客さんから得た情報
        - DDL一式（実行して必要十分なテーブルを生成する）
    - DB設計の大まかな流れ
        - 要件を聞く、情報を集める→データベース設計作業→DDl作成
    - データベース設計作業の中でも主に3つに分かれる
        - 概念設計
            - 管理する情報(データ)は何があるのかを明らかにする
            - 言い換えるとエンティティとその属性を明らかにする作業。
            - 「顧客情報」「入出金情報」「製品」などなど
            - 具体的な作業としてはER図のを作るということ
            - エンティティを明らかにする時のコツ
                - 要件の中から候補となる用語を洗い出す
                - その要件に登場する「人」「もの」「事実」「行為」が何かを考えつつ用語を出す
                - 何かの具体でしかない用語はすてる（利用者があるなら、田中さんは捨てて良い）
                - 計算や集計すれば出るものも捨てる
                - 関連のある用語たちをまとめていく（日付、利用者、金額、内容などであれば入出金行為テーブルだなってかんじ）
                - 大事なのは正解はないという前提を忘れないこと。お互いに自分なりの正解を見せ合い、意見交換し、良いものにしてく
        - 論理設計
            - 概念設計で作ったエンティティとその関係をDBに登録して使えるように修正していく作業
            - 流れとしては、多対多の分解→キーの整理→正規化の流れ
            - 多対多の分解
                - RDBは多対多を上手く扱えないのであればテーブルを分解する
                - 1対多にする
            - キーの整理
                - 主キー、外部キーはどの列になるか整理する。主キーがなければ人工キーを作成する
            - 正規化
                - 正規化によってテーブルが適切に分割された状態を正規形という。
                - 第1~第5正規形まで存在する
                - 非正規系
                    - セルの結合がある、1セルに複数行ある
                    - つまり繰り返しの列がある状態
                - 第一正規系
                    - テーブルの全行の全列に1つの値が入っている。
                    - 主キー以外の全列が、主キーに従属していること
                - 第二正規系
                    - 複合主キーがある場合は複合主キー以外の列が複合主キーに綺麗に従属している
                    - 複合主キーの片方に従属している非主キーは存在しないようにする
                - 第三正規系
                    - 間接的に主キーの従属している列を排除する
        - 物理設計
            - 最終的なテーブル名、列名を決める、列のデータ型を決める、制約デフォルト値を決める、インデックスを決定する
            - DB内にテーブルを作成する


