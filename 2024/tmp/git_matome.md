## もう怖くないGit！チーム開発で必要なGitを完全マスター
https://git-scm.com/doc

![alt text](image.png) 
- ローカルは、ワークツリー、ステージ、リポジトリに分かれている。

![alt text](image-1.png)
- git addの裏側の動き
    - index.htmlを作成していた場合、index.htmlのファイルの中身を圧縮したした圧縮ファイルをリポジトリに保存する。（ここではべb義的に圧縮ファイルAと呼ぶ。）（ファイル名はファイルの中身をハッシュ関数で暗号化した文字列になる）
    - 次にINDEX（ステージ）に、index.htmlは圧縮ファイルAだというファイル名とファイルの中身をマッピングした情報を記載する

![alt text](image-2.png)
- git commitの裏側の動き
    - インデックスのファイル構成をもとにツリー1というファイルが作られる。ツリー1はインデックスに記載されているファイル構成を改めて保存したもの。
    - 次にコミット1というファイルを作成する。
    ツリー1のファイル名、作成者(git configのメアドとユーザ名) 、日付、コミットメッセージ等の情報が書かれている。
    -git commitは上記２ファイルを作成する
    - ツリー１からコミットされたファイル構成、つまりファイル名とファイル内容がわかる。
    つまりコミット１というファイルから、その問のファイル状態と誰がいつなんのために変更したのかがわかる
    - コミットの際は、画像の通り、圧縮ファイル、ツリー、コミットという３ファイルを作成し保存している


![alt text](image-3.png)
- 新たにファイルを追加したら
    - css/home.cssを作成したとする。
    - git addでhome.cssの圧縮ファイルを作成する。すなわちリポジトリに圧縮ファイルBが作成される。
    - 次にインデックスに圧縮ファイルBはcss/home.cssだよというファイル構成を追記する。これでgit add完了。
    - 次にgit commit する。まずツリー２が作成される。ツリーファイルには今のステージの状態（インデックスに記載されているあファイル構成）が保存される
    - 次にコミット２というコミットファイルを作成していく。コミット２にはツリー２というツリー名が記録される。そしてここが特異で、親コミットつまり直前のコミット（さっきのコミット１）の情報も書かれる。後は作成者日付コミットメッセージを記録しておしまい。

![alt text](image-4.png)
- ファイルを変更したら
    - index.htmlに変更を加えたとする。
    - git addで圧縮ファイルCが作られる。この時圧縮ファイルが作られるのはindex.htmlだけで、変更してないhome.cssに関しては作られない。（圧縮ファイルはあくまでもファイルの内容が違う時にだけ新しく作られる。）
    - 圧縮ファイルが作られたので、そのじょ右方をインデックスに追記していく。index.htmlが圧縮ファイルAですよとマッピングされていたものが、今回圧縮ファイルCですよにマッピングし直される。
    - そしてコミットする。まずインデックスの内容をもとにツリー３が作られる。次にコミット３というコミットファイルが作られる。こ

- ここまでのまとめ。
    - リポジトリに「圧縮ファイル」「ツリー」「コミット」ファイルを作成することでデータを保存している。
    - コミットが親コミットを持つことで変更履歴を辿ることができる
    - Gitの本質はデータを圧縮してスナップショットを保存していること

- Gitデータ管理の補足
    - 先のリポジトリに作られた「圧縮ファイル」「ツリー」「コミット」ファイルは「Gitオブジェクト」と呼ぶ。.git/objectsディレクトリ配下に保存される。
    - 圧縮ファイルに関して
        - 正確には圧縮ファイルは「blob(ブロブ)オブジェクト」と呼ばれる。blobは塊という意味。ファイルの中身を圧縮しただけの塊の意味。
        - 圧縮ファイルのファイル名はハッシュIDになる。
        - ハッシュIDというのは、ヘッダー（ファイル内容の文字数など、ファイルのメタ情報）とファイル内容を、SHA-1というハッシュ関数で40文字の英数字に変換したものです。ハッシュIDのうち、先頭2文字をディレクトリ名に、残り38文字をファイル名にして保存します。
    ![alt text](image-5.png)
        - git hash-object はgitオブジェクトのオブジェクトIDを返します。
        - このようにハッシュIDは、「ce013625030ba8dba906f756967f9e9ca394464a」という40文字の英数字になります。
    ![alt text](image-6.png)
        - 圧縮ファイルは「.git/objects/ce/013625030ba8dba906f756967f9e9ca394464a」として保存されています。
        - ここで重要なことは、ハッシュIDというのは、ファイルの中身に対して一意になるということです。中身が同じファイルであれば必ず同じハッシュIDになります。そのため、ファイルの中身が同じであれば git add しても追加で圧縮ファイルが作られることはありませんし、ファイルの中身に変更があれば git add すると別の圧縮ファイルが作成されます。
    - ツリーファイルに関して
        - 圧縮ファイルはあくまでファイルの中身を圧縮しているだけなのでファイル名は残っていない。そこでファイル名とファイルの中身の組み合わせを保存したのがツリーファイル(treeオブジェクトという)
        - 動画ではファイル名と圧縮ファイル名の組み合わせを保存したものとして説明しました。実際は、ディレクトリの一つの階層ごとに一つのツリーファイルになっていて、ツリーファイルには圧縮ファイルだけでなくツリーファイルも保存されています

        ![alt text](image-7.png)
        - 最後のコミットが指しているtreeには、blobオブジェクト「ce013625030ba8dba906f756967f9e9ca394464a」が greeting というファイル名だ、ということが保存されています。

        ![alt text](image-8.png)
        ![alt text](image-9.png)
        - 、一つのファイルに一つの圧縮ファイルが対応していて（※）、一つのディレクトリに一つのツリーファイルが対応していることがわかります

    - コミットファイルに関して
        - ツリーファイルが作成されたことで、ファイルの構造がわかるようになりました。しかしまだ、いつ、誰が、何を、何のために変更したのかということがわかりません。そこで、その情報を保存するためにあるのがコミットファイルでした。コミットファイルは正確には「commitオブジェクト」と言います。
        ![alt text](image-10.png)
        - まず、コミットした時点のtree「ad1c184780f07f18df81d704d83f6e66dadfdff3」が保存されています。これはこのプロジェクトの一番上のディレクトリのツリーファイルになります。一番上の階層のツリーをコミットファイルに保存することで、コミットした時点でのスナップショットを記録しています。

        - 次がparent、親コミットを保存しています。親コミットは「65bf0df5cda8ec94f6e8a998314b0281814304e1」です。Gitはこのように親コミットを保存することでコミットの履歴を辿れるようにしているんでしたね。

        - あとは作成者の名前とメールアドレス、改行、コミットメッセージと続きます。これで、変更者と変更理由がわかります。
        ![alt text](image-11.png)
        - 写真のacd75dはad1c18
        ae682fは65bf0に読みかえ
    - .gitのようにドットから始まるフォルダは隠れフォルダというｓ
    - objects内に圧縮ファイルやツリーファイルやコミットファイルが保存されていく
    - `git clone` →リモートのファイルがワークツリーにコピーされる。かつ.gitディレクトリがコピーされる
    - インデックスの中身は、`git ls-files --stage`で見ることができます。(git addした際に作られるindexと圧縮ファイルのうちインデックスの方。)
    ![alt text](image-12.png)
    - .git ディレクトリの構造確認は`tree .git`で確認できる
    - git add で圧縮ファイルがobjectsは以下に作られる。コミットすると、objects下にツリーとコミットのオブジェクトが作られる
    なので、add,commitで合計3つobjects下にできる

